# TSS-Based Settlement and Payout Specification

## Abstract
This document defines how Bittery executes Bitcoin payouts using threshold signatures (TSS). It covers prize pool address generation, payout transaction composition, royalty and treasury distributions, change handling, rollover logic, and refunds.

## Motivation
Bitcoin requires valid signatures to spend UTXOs. Using TSS provides distributed control over the prize pool, eliminating reliance on a single private key while enabling automated payouts determined by the ICP final judge.

## Specification
### Prize Pool Address Generation
- A round-specific TSS key pair is generated by the signing committee.
- The public key is converted to a SegWit Bech32 address (`prize_pool_address`) and published in the BII.
- All bets MUST pay this address; only the TSS committee can spend the UTXO set.

### Payout Transaction Structure
Outputs MUST follow this order unless otherwise specified in BII:
1. **Winner outputs**: One output per selected winner, amount determined by `payout_policy` share.
2. **Treasury outputs**: Distributed according to `treasury_outputs` weights.
3. **Issuer output**: Amount per `issuer_bps` share to the issuer address (defined off-chain or via treasury list).
4. **Rollover output**: Residual funds allocated to `rollover_target_round_id` prize pool address if rollover is enabled.
5. **Change output**: Remaining satoshis after fees, sent to a designated TSS change address.

### Amount Calculation
- Let `P` be the sum of all eligible bet inputs to the payout transaction.
- Transaction fee `F` is estimated using current feerate and subtracted from `P`.
- Distributions are calculated in basis points: `amount = (P - F) * share_bps / 10_000`.
- Any dust remainder is added to the change output or, if change is dust, to the largest winner output.

### TSS Signing
- The ICP final judge constructs the unsigned payout transaction referencing unspent prize pool UTXOs.
- The transaction digest is broadcast to TSS participants.
- Upon collecting threshold signatures (e.g., t-of-n), the aggregated signature is inserted and the transaction is broadcast to Bitcoin.
- The resulting `txid` and raw transaction are recorded for audit.

### Rollover Logic
- If `rollover` is true in BII, unallocated funds (including change) are sent to the prize pool address of `rollover_target_round_id`.
- If the target round is not yet initialized, funds remain locked until the subsequent payout transaction spends them with a valid TSS signature.

### Refund Logic
- If `min_tickets` is not met, the round enters refund mode. The payout transaction instead returns pro-rata funds to the originating bet addresses or to a designated refund address controlled by the operator, as specified by BII notes or implementation policy.
- Refund mode still requires TSS signatures to spend the prize pool UTXOs.

### Example Transaction (conceptual)
```
Input: UTXO from prize_pool_address (value: 1.00000000 BTC)

Outputs:
  0: 0.60000000 BTC -> winner1 (P2WPKH)
  1: 0.02000000 BTC -> winner2 (P2WPKH)
  2: 0.02000000 BTC -> winner3 (P2WPKH)
  3: 0.02000000 BTC -> winner4 (P2WPKH)
  4: 0.02000000 BTC -> winner5 (P2WPKH)
  5: 0.10000000 BTC -> treasury split A/B per weights
  6: 0.10000000 BTC -> issuer
  7: 0.10000000 BTC -> rollover target prize pool
  8: 0.02000000 BTC -> change address
Fee: 0.00000000 BTC (for illustration)
```

## Data Structures
- `PayoutPlan`: `{inputs, outputs[], fee, rollover_target, change_address}`
- `TSSSignatureBundle`: `{participants[], threshold, aggregated_signature}`

## Validation
1. Verify all inputs belong to `prize_pool_address` or prior rollover outputs.
2. Recompute allocations from eligible bet total and confirm outputs match calculated amounts within dust tolerance.
3. Validate aggregated TSS signature against the roundâ€™s public key.
4. Ensure no unauthorized outputs exist and ordering matches specification.
5. Confirm payout transaction is not double-spending and meets mempool policy (fee rate, size).

## Rationale
TSS enables decentralized control of funds while keeping a single on-chain address for simplicity. Basis point calculations provide deterministic splits that are easy to audit.

## Security Considerations
- **Key compromise**: Distributed key shares reduce single-point failure risk; threshold requirement prevents unilateral spending.
- **Replay**: Payout transaction references specific UTXOs; replays on forks are mitigated by relying on the active chain state.
- **Incorrect splits**: Deterministic calculation and validation prevent misallocation of funds.
- **Rollover custody**: Rollover outputs remain under TSS control, preventing operator seizure.
