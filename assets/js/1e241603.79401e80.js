"use strict";(globalThis.webpackChunkbittery_docs=globalThis.webpackChunkbittery_docs||[]).push([[2937],{1663:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"VRF-spec","title":"VRF & Entropy Specification","description":"Abstract","source":"@site/docs/VRF-spec.md","sourceDirName":".","slug":"/VRF-spec","permalink":"/VRF-spec","draft":false,"unlisted":false,"editUrl":"https://github.com/bittery-protocol/bittery-docs/edit/main/docs/VRF-spec.md","tags":[],"version":"current","frontMatter":{}}');var t=n(6070),s=n(9438);const o={},c="VRF & Entropy Specification",d={},a=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Specification",id:"specification",level:2},{value:"Entropy Sources",id:"entropy-sources",level:3},{value:"VRF Input Construction",id:"vrf-input-construction",level:3},{value:"VRF Output",id:"vrf-output",level:3},{value:"Winner Mapping",id:"winner-mapping",level:3},{value:"Visualization Mapping (Powerball-style)",id:"visualization-mapping-powerball-style",level:3},{value:"Data Structures",id:"data-structures",level:2},{value:"Validation",id:"validation",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Security Considerations",id:"security-considerations",level:2}];function l(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"vrf--entropy-specification",children:"VRF & Entropy Specification"})}),"\n",(0,t.jsx)(i.h2,{id:"abstract",children:"Abstract"}),"\n",(0,t.jsx)(i.p,{children:"This document specifies the entropy sources and verifiable random function (VRF) procedures used to select winners in Bittery rounds. The process is deterministic, reproducible, and anchored to Bitcoin block data to prevent bias."}),"\n",(0,t.jsx)(i.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsxs)(i.p,{children:["Bitcoin does not provide native randomness. Bittery requires a transparent and replayable mechanism so that any party can derive the same random output from public inputs. Combining Bitcoin block hashes with a VRF ensures unpredictability before ",(0,t.jsx)(i.code,{children:"end_block"})," and verifiability afterward."]}),"\n",(0,t.jsx)(i.h2,{id:"specification",children:"Specification"}),"\n",(0,t.jsx)(i.h3,{id:"entropy-sources",children:"Entropy Sources"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Block Hash Seed"}),": The Bitcoin block hash at height ",(0,t.jsx)(i.code,{children:"end_block"})," after ",(0,t.jsx)(i.code,{children:"k_confirm"})," confirmations. In the event of a reorg, the new confirmed hash replaces the seed."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"raw_rand()"}),": Optional deterministic randomness provided by the execution environment (e.g., ICP\u2019s raw randomness) for additional entropy. Must be recorded for reproduction."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Commit\u2013reveal (optional)"}),": If configured, participants may include commitments in bets; reveals occurring before DRAWING are concatenated into the entropy transcript. Validators MUST ignore reveals after DRAWING begins."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"vrf-input-construction",children:"VRF Input Construction"}),"\n",(0,t.jsxs)(i.p,{children:["The VRF message ",(0,t.jsx)(i.code,{children:"M"})," is constructed as:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:'M = concat(\n  "Bittery-VRF",                // domain separator\n  round_id,                      // bytes\n  end_block_height (uint64 BE),\n  end_block_hash (32 bytes),\n  k_confirm (uint8),\n  raw_rand() output if present,\n  commit_reveal_transcript if present\n)\n'})}),"\n",(0,t.jsx)(i.h3,{id:"vrf-output",children:"VRF Output"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"The VRF is executed with a round-specific VRF key pair controlled by the ICP canister."}),"\n",(0,t.jsxs)(i.li,{children:["The output is a 64-bit integer ",(0,t.jsx)(i.code,{children:"R64"})," derived from the VRF hash output by taking the first 8 bytes as big-endian."]}),"\n",(0,t.jsxs)(i.li,{children:["The VRF proof MUST accompany ",(0,t.jsx)(i.code,{children:"R64"})," and be verifiable against the public VRF key."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"winner-mapping",children:"Winner Mapping"}),"\n",(0,t.jsxs)(i.p,{children:["Given ",(0,t.jsx)(i.code,{children:"n"})," eligible tickets (expanded from ",(0,t.jsx)(i.code,{children:"tid"})," counts), winners are selected by deterministic modular mapping:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"for i in 0..(winners_needed-1):\n  index_i = (R64 + i * c) mod n\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Where ",(0,t.jsx)(i.code,{children:"c"})," is a large odd constant (e.g., 0x9e3779b97f4a7c15) to ensure full-period cycling. Duplicate indices must be skipped to preserve unique winners; increment ",(0,t.jsx)(i.code,{children:"i"})," until required winners are selected."]}),"\n",(0,t.jsx)(i.h3,{id:"visualization-mapping-powerball-style",children:"Visualization Mapping (Powerball-style)"}),"\n",(0,t.jsxs)(i.p,{children:["For user-facing visualization, ",(0,t.jsx)(i.code,{children:"R64"})," can be expanded to five white balls and one red ball:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"white1 = (R64 >> 0)  mod 69\nwhite2 = (R64 >> 8)  mod 69\nwhite3 = (R64 >> 16) mod 69\nwhite4 = (R64 >> 24) mod 69\nwhite5 = (R64 >> 32) mod 69\nred    = (R64 >> 40) mod 26\n"})}),"\n",(0,t.jsx)(i.p,{children:"This mapping is non-authoritative for payouts but provides a reproducible representation."}),"\n",(0,t.jsx)(i.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"VRFInput"}),": ",(0,t.jsx)(i.code,{children:"{round_id, end_block_height, end_block_hash, k_confirm, raw_rand_opt, commit_reveal_transcript}"})]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"VRFOutput"}),": ",(0,t.jsx)(i.code,{children:"{R64, proof}"})]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"validation",children:"Validation"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["Verify the VRF proof against the public key and message ",(0,t.jsx)(i.code,{children:"M"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Ensure ",(0,t.jsx)(i.code,{children:"end_block_hash"})," corresponds to the chain view with ",(0,t.jsx)(i.code,{children:"k_confirm"})," confirmations after ",(0,t.jsx)(i.code,{children:"end_block"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Confirm ",(0,t.jsx)(i.code,{children:"raw_rand()"})," and commit\u2013reveal components (if used) are logged and identical across verifiers."]}),"\n",(0,t.jsx)(i.li,{children:"Confirm winner indices map to the frozen eligible ticket list without duplication."}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsxs)(i.p,{children:["Using the confirmed ",(0,t.jsx)(i.code,{children:"end_block_hash"})," anchors randomness to Bitcoin while the VRF proof guarantees publicly verifiable derivation. The modular stepping approach yields uniform selection across ticket space without bias."]}),"\n",(0,t.jsx)(i.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Bias resistance"}),": Waiting for confirmations reduces miner influence over ",(0,t.jsx)(i.code,{children:"end_block_hash"}),". VRF proof prevents manipulation by the execution environment."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Reorg handling"}),": Recomputing with the new confirmed hash ensures consistency after chain reorganizations."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Transcript integrity"}),": All entropy inputs must be recorded to allow third parties to reproduce ",(0,t.jsx)(i.code,{children:"R64"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);