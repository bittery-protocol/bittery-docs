"use strict";(globalThis.webpackChunkbittery_docs=globalThis.webpackChunkbittery_docs||[]).push([[7873],{4031:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"indexer-flow","title":"Indexer \u2192 Canister Flow (per Bitcoin block)","description":"This page summarizes the operational flow between off-chain indexers, the indexer-canister, and the main canister. It is derived from the latest engineering runbook.","source":"@site/docs/indexer-flow.md","sourceDirName":".","slug":"/indexer-flow","permalink":"/indexer-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/bittery-protocol/bittery-docs/edit/main/docs/indexer-flow.md","tags":[],"version":"current","frontMatter":{}}');var s=r(6070),t=r(9438);const o={},l="Indexer \u2192 Canister Flow (per Bitcoin block)",c={},d=[{value:"Overview",id:"overview",level:2},{value:"Sequence (per block)",id:"sequence-per-block",level:2},{value:"Key Rules",id:"key-rules",level:2},{value:"API Sketch",id:"api-sketch",level:2},{value:"Failure &amp; Reorg Handling",id:"failure--reorg-handling",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"indexer--canister-flow-per-bitcoin-block",children:"Indexer \u2192 Canister Flow (per Bitcoin block)"})}),"\n",(0,s.jsx)(n.p,{children:"This page summarizes the operational flow between off-chain indexers, the indexer-canister, and the main canister. It is derived from the latest engineering runbook."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cadence"}),": On every Bitcoin block, indexers scan BTRY OP_RETURNs and prize outputs, group by ",(0,s.jsx)(n.code,{children:"round_id"}),", and compute Merkle roots."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Upload path"}),": Indexers send a block summary to ",(0,s.jsx)(n.code,{children:"indexer-canister"}),"; the main canister pulls/receives these summaries."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-game support"}),": A block can carry multiple rounds/plays; summaries are aggregated per ",(0,s.jsx)(n.code,{children:"round_id"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reorg handling"}),": Track ",(0,s.jsx)(n.code,{children:"(block_height, block_hash)"}),"; if a reorg is detected, rollback affected heights and re-fetch."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"sequence-per-block",children:"Sequence (per block)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[Bitcoin block N]\n    |\n    v\nIndex scan\n  - Parse BTRY (Init/Bet/Term)\n  - Drop invalid entries (amount/window/duplicate ticket)\n  - Group by round_id, produce {round_id, root, count, total_amt, block_height, block_hash}\n    |\n    v\nUpload to indexer-canister\n  submit_block_summary(height, block_hash, entries[])\n    |\n    v\nMain canister pull/subscribe\n  - Collect roots per block/round from multiple indexers\n  - \u22652/3 matching roots -> accept; else dispute path with extra data sources\n  - Mark pending until K confirmations\n    |\n    v  (block reaches K confs)\nFinalize\n  - Write VerifiedBets (round_id -> root/count/height/hash)\n  - Update round counters/amounts\n    |\n    v\nDraw/settle once round closed and data sufficient\n"})}),"\n",(0,s.jsx)(n.h2,{id:"key-rules",children:"Key Rules"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"One report per block"}),": Consolidate all rounds for the block to reduce calls; if sharded, use a block-level nonce when merging."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Confirmation delay"}),": Main canister only accepts after ",(0,s.jsx)(n.code,{children:"k_confirm"})," (recommended 6) to limit reorg risk."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-source consensus"}),": Require N indexers; accept roots when \u22652/3 match. Otherwise trigger dispute checks using multiple Bitcoin data sources."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Uniqueness"}),": Bet key uses ",(0,s.jsx)(n.code,{children:"(txid:vout)"})," or ",(0,s.jsx)(n.code,{children:"(g,r)"}),"; duplicates are dropped."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Term policy"}),": Term is only a signal; residual pot follows Init-fixed ",(0,s.jsx)(n.code,{children:"po/tr"})," and cannot be changed by Term."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"api-sketch",children:"API Sketch"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"submit_block_summary(height, block_hash, entries)"})," where ",(0,s.jsx)(n.code,{children:"entries"})," contain ",(0,s.jsx)(n.code,{children:"{round_id, merkle_root, count, total_amt, block_hash}"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"get_round_snapshots(round_id, from_height?, to_height?)"})," for audits."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"get_block(height)"})," returns per-round roots aggregated for that height."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"failure--reorg-handling",children:"Failure & Reorg Handling"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Detect hash changes for any recorded height; rollback the affected window and request fresh summaries."}),"\n",(0,s.jsx)(n.li,{children:"Re-run consensus on the recomputed roots; only proceed when \u22652/3 agree."}),"\n",(0,s.jsx)(n.li,{children:"Log incidents for audit; keep full winner lists/VRF transcript/tx construction details in an archive canister with paged queries."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}}}]);